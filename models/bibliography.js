/**
 * @file Bibliography pattern
 * @author Guillaume Brioudes <https://myllaume.fr/>
 * @copyright GNU GPL 3.0 ANR HyperOtlet
 */

/**
 * @typedef BibliographicRecord
 * @type {object}
 * @property {number} idRecord
 * @property {string} quotes
 * @property {string} bibliography HTML
 */

const CSL = require('citeproc')
    , Citr = require('@zettlr/citr');

module.exports = class Bibliography {
    /**
     * For each record, get all quoting keys from its content
     * @param {Record} record
     * @return {BibliographicRecord}
     */

    static getQuotesFromRecord(record) {
        const { id: recordId, content } = record;
        const recordQuotes = {};

        let extractions = Citr.util.extractCitations(content);

        quoteExtraction:
        for (let i = 0; i < extractions.length; i++) {
            const extraction = extractions[i];

            let quotes;

            try {
                quotes = Citr.parseSingle(extraction);
            } catch (error) {
                quotes = [];
            }

            // there could be several quotes from one key
            for (const q of quotes) {

                if (!this.library[q.id]) {
                    // if the quote id is not defined from library
                    // this.report.quotes_without_reference.push({ fileName: file.name, quoteId: q.id })
                    continue quoteExtraction;
                }

                this.library[q.id].used = true;
            }

            recordQuotes[extraction] = quotes;
        }

        return {
            idRecord: recordId,
            quotes: recordQuotes
        };
    }

    /**
     * The objects generated by this.catchQuoteKeys() are too deep
     * This function find for each quote entry all the included ids
     * @param {number} quoteObject
     * @returns {array}
     * @static
     */

    static getQuoteKeysFromQuoteObject(quotes) {
        return Object.values(quotes)
            .map(function(key) {
                let ids = [];
    
                for (const cit of key) {
                    ids.push(cit.id);
                }
    
                return ids;
            })
            .flat();
    }

    /**
     * @param {object} library
     * @param {string} cslStyle
     * @param {string} xmlLocal
     * @param {Record[]} records
     * @returns
     * @exemple
     * ```
     * const { records } = new Graph(records, undefined, []);
     * const bibliography = new Bibliography(
     *      [
     *          {
     *              "id": "Goody_1979",
     *              "type": "book",
     *              "title": "La Raison graphique: la domestication de la pensÃ©e sauvage",
     *              ...
     *              "author": [
     *                  {
     *                      "family": "Goody",
     *                      "given": "Jack"
     *                  }
     *              ],
     *              "issued": { "date-parts": [[1979]] }
     *          },
     *      ],
     *      '<?xml version="1.0" encoding="utf-8"?><style xmlns="http://purl.org/net/xbiblio/csl" ...> ... </style>',
     *      '<?xml version="1.0" encoding="utf-8"?><locale xmlns="http://purl.org/net/xbiblio/csl" ...> ... </locale>',
     *      records
     * );
     * ```
     */

    constructor(library = {}, cslStyle, xmlLocal, records) {
        this.library = {};
        for (const { id, ...rest } of Object.values(library)) {
            this.library[id] = { id, ...rest };
        }
        this.cslStyle = cslStyle;
        this.xmlLocal = xmlLocal;

        if (!this.cslStyle || !this.xmlLocal) {
            return;
        }

        this.citeproc = this.getCSL();

        /** @type {BibliographicRecord[]} */
        this.bibliographicRecords;
        this.bibliographicRecords = records.map(Bibliography.getQuotesFromRecord, this);
        this.bibliographicRecords = this.bibliographicRecords.map(this.addMarknBibliographyForEachQuoting, this);
    }

    /**
     * @param {BibliographicRecord} bibliographicRecord 
     * @returns {BibliographicRecord}
     */
    
    addMarknBibliographyForEachQuoting (bibliographicRecord) {
        const { quotes } = bibliographicRecord;

        this.citeproc.updateItems(Bibliography.getQuoteKeysFromQuoteObject(quotes));

        const citations = Object.values(quotes).map((key, i) => {
            return [{
                citationItems: key,
                properties: { noteIndex: i + 1 }
            }];
        });

        for (let i = 0; i < citations.length; i++) {
            const cit = citations[i];
            const key = Object.keys(quotes)[i]
            const citMark = this.citeproc.processCitationCluster(cit[0], [], [])[1][0][1];
            bibliographicRecord.quotes[key]['mark'] = citMark;
        }

        bibliographicRecord['bibliography'] = this.citeproc.makeBibliography()[1].join('\n');

        return bibliographicRecord;
    }

    /**
     * Get 'citeproc' engine, from library (JSON CSL) and config files (XML, CSL)
     * @returns {CSL} - Engine for quote process
     */

    getCSL () {
        return new CSL.Engine({
            retrieveLocale: () => {
                return this.xmlLocal;
            },
            retrieveItem: (id) => {
                // find the quote item : CSL-JSON object
                return this.library[id];
            }
        }, this.cslStyle);
    }
}